import sqlite3
from contextlib import closing

from dataclasses import dataclass


@dataclass(frozen=True)
class Vulnerability:
    id: str
    package_name: str
    namespace: str
    package_qualifiers: str | None = None
    version_constraint: str | None = None
    version_format: str | None = None
    cpes: str | None = None
    related_vulnerabilities: str | None = None
    fixed_in_versions: str | None = None
    fix_state: str | None = None
    advisories: str | None = None


@dataclass(frozen=True)
class VulnerabilityMetadata:
    id: str
    namespace: str
    data_source: str
    record_source: str
    severity: str
    description: str
    urls: str | None = None
    cvss: str | None = None


@dataclass(frozen=True)
class VulnerabilityRecordPair:
    vulnerability: Vulnerability
    metadata: VulnerabilityMetadata


def compare_vulnerability_sets(
    set_a: set[VulnerabilityRecordPair],
    set_b: set[VulnerabilityRecordPair],
    fields_to_compare: list[str] = [],
) -> tuple[set[tuple], set[tuple]]:
    """
    Compares two sets of VulnerabilityRecordPairs, identifying missing or extra records
    in set_a relative to set_b, based on specific fields or all fields if none are specified.

    Args:
    - set_a: First set of VulnerabilityRecordPair to compare.
    - set_b: Second set of VulnerabilityRecordPair to compare.
    - fields_to_compare: List of field names to compare. If empty, all fields are compared.

    Returns:
    - A tuple containing two sets:
        - missing_in_a: Items in set_b but not in set_a
        - extra_in_a: Items in set_a but not in set_b
    """

    def record_to_tuple(record: VulnerabilityRecordPair, fields: list[str]) -> tuple:
        """
        Converts a VulnerabilityRecordPair to a tuple of values based on specified fields.
        """
        vulnerability_dict = record.vulnerability.__dict__
        metadata_dict = record.metadata.__dict__

        if fields:
            return tuple(
                vulnerability_dict.get(field) or metadata_dict.get(field)
                for field in fields
            )
        else:
            # Compare all fields if fields_to_compare is empty
            return tuple(vulnerability_dict.values()) + tuple(metadata_dict.values())

    # Convert records in each set to tuples of values based on fields_to_compare
    set_a_tuples = {record_to_tuple(record, fields_to_compare) for record in set_a}
    set_b_tuples = {record_to_tuple(record, fields_to_compare) for record in set_b}

    # Calculate differences
    missing_in_a = set_b_tuples - set_a_tuples  # Items in set_b but not in set_a
    extra_in_a = set_a_tuples - set_b_tuples  # Items in set_a but not in set_b

    return missing_in_a, extra_in_a


class VulnerabilityDB:
    def __init__(self, db_path: str):
        """
        Initializes the VulnerabilityDB instance and opens a connection to the SQLite database.

        Args:
        - db_path: Path to the SQLite database.
        """
        self.db_path = db_path
        self.conn = sqlite3.connect(self.db_path)

    def get_package_names(self, vuln_id: str) -> set[str]:
        """
        Queries the database for distinct package names in the 'vulnerability' table where
        the namespace contains 'red' and the id matches the provided vuln_id.

        Args:
        - vuln_id: The vulnerability ID to search for.

        Returns:
        - A set of distinct package names matching the query.
        """
        query = """
        SELECT DISTINCT package_name 
        FROM vulnerability 
        WHERE namespace LIKE "%red%" AND id = ?
        """
        with closing(self.conn.cursor()) as cursor:
            cursor.execute(query, (vuln_id,))
            # Fetch all results and convert them to a set of strings
            results = {row[0] for row in cursor.fetchall()}
        return results

    def get_vulnerability_records(self, id: str) -> list[VulnerabilityRecordPair]:
        """
        Fetches vulnerability records from the database where the id matches the given id
        and the namespace contains 'red'.

        Args:
        - id (str): The vulnerability ID to search for.

        Returns:
        - List[VulnerabilityRecordPair]: A list of VulnerabilityRecordPair instances matching the criteria.
        """
        query = """
        SELECT
            v.id, v.package_name, v.namespace, v.package_qualifiers, v.version_constraint,
            v.version_format, v.cpes, v.related_vulnerabilities, v.fixed_in_versions,
            v.fix_state, v.advisories,
            vm.data_source, vm.record_source, vm.severity, vm.urls, vm.description, vm.cvss
        FROM vulnerability AS v
        JOIN vulnerability_metadata AS vm
        ON v.id = vm.id AND v.namespace = vm.namespace
        WHERE v.namespace LIKE "%red%" AND v.id = ?
        """

        results = []
        with closing(self.conn.cursor()) as cursor:
            cursor.execute(query, (id,))

            # Fetch all results and build VulnerabilityRecordPair instances
            for row in cursor.fetchall():
                vulnerability = Vulnerability(
                    id=row[0],
                    package_name=row[1],
                    namespace=row[2],
                    package_qualifiers=row[3],
                    version_constraint=row[4],
                    version_format=row[5],
                    cpes=row[6],
                    related_vulnerabilities=row[7],
                    fixed_in_versions=row[8],
                    fix_state=row[9],
                    advisories=row[10],
                )
                metadata = VulnerabilityMetadata(
                    id=row[0],
                    namespace=row[2],
                    data_source=row[11],
                    record_source=row[12],
                    severity=row[13],
                    urls=row[14],
                    description=row[15],
                    cvss=row[16],
                )
                results.append(
                    VulnerabilityRecordPair(
                        vulnerability=vulnerability, metadata=metadata
                    )
                )

        return results

    def close(self):
        """Closes the database connection."""
        if self.conn:
            self.conn.close()
